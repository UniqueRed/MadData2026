"""
MEPS Data Loader

Loads the pre-processed MEPS cost tables (generated by meps_processor.py)
and provides query functions for the simulation engine.

Data is loaded once at module import and cached in memory.
"""

import json
import pandas as pd
from pathlib import Path
from functools import lru_cache

_DATA_DIR = Path(__file__).resolve().parent / "processed"

# ── Load processed data at import time ──

_cost_table: pd.DataFrame | None = None
_condition_summary: dict | None = None
_comorbidity_costs: dict | None = None
_drug_costs_by_condition: dict | None = None
_intervention_drug_costs: dict | None = None


def _ensure_loaded():
    """Lazy-load processed data on first access."""
    global _cost_table, _condition_summary, _comorbidity_costs
    global _drug_costs_by_condition, _intervention_drug_costs

    if _condition_summary is not None:
        return

    costs_path = _DATA_DIR / "condition_costs.csv"
    summary_path = _DATA_DIR / "condition_summary.json"
    comorbidity_path = _DATA_DIR / "comorbidity_costs.json"
    drug_costs_path = _DATA_DIR / "drug_costs_by_condition.json"
    intervention_costs_path = _DATA_DIR / "intervention_drug_costs.json"

    if not summary_path.exists():
        raise FileNotFoundError(
            f"Processed MEPS data not found at {_DATA_DIR}. "
            "Run: python -m app.data.meps_processor"
        )

    _cost_table = pd.read_csv(costs_path)
    with open(summary_path) as f:
        _condition_summary = json.load(f)
    with open(comorbidity_path) as f:
        _comorbidity_costs = json.load(f)

    # Load H239 drug cost data (optional — generated by drug_cost_processor.py)
    if drug_costs_path.exists():
        with open(drug_costs_path) as f:
            _drug_costs_by_condition = json.load(f)
    else:
        _drug_costs_by_condition = {}

    if intervention_costs_path.exists():
        with open(intervention_costs_path) as f:
            _intervention_drug_costs = json.load(f)
    else:
        _intervention_drug_costs = {}


def _age_to_group(age: int) -> str:
    """Convert an age to the age group bucket used in our processed data."""
    if age < 30:
        return "<30"
    elif age < 40:
        return "30-39"
    elif age < 50:
        return "40-49"
    elif age < 60:
        return "50-59"
    elif age < 70:
        return "60-69"
    elif age < 80:
        return "70-79"
    else:
        return "80+"


def _insurance_to_type(insurance_type: str) -> str:
    """Map the engine's insurance type strings to our MEPS categories."""
    ins = insurance_type.upper()
    if ins in ("PPO", "HMO", "HDHP", "PRIVATE", "EMPLOYER"):
        return "private"
    elif ins in ("MEDICARE", "MEDICAID", "PUBLIC"):
        return "public"
    elif ins in ("UNINSURED", "NONE"):
        return "uninsured"
    return "private"  # default fallback


def query_cost(
    condition: str,
    age: int = 45,
    sex: str = "M",
    insurance_type: str = "PPO",
) -> dict:
    """
    Query the expected annual cost for a single condition, stratified by
    age group, sex, and insurance type.

    Returns dict with keys:
        mean_total_exp, median_total_exp, mean_oop, median_oop,
        incremental_cost, n, source ("stratified" or "summary")

    Falls back to unstratified summary if the stratified cell is too thin.
    """
    _ensure_loaded()

    age_group = _age_to_group(age)
    sex_val = sex.upper()[:1]
    ins_type = _insurance_to_type(insurance_type)

    # Try stratified lookup first
    match = _cost_table[
        (_cost_table["condition"] == condition)
        & (_cost_table["age_group"] == age_group)
        & (_cost_table["sex"] == sex_val)
        & (_cost_table["insurance_type"] == ins_type)
    ]

    if len(match) > 0 and match.iloc[0]["n"] >= 10:
        row = match.iloc[0]
        return {
            "mean_total_exp": row["mean_total_exp"],
            "median_total_exp": row["median_total_exp"],
            "mean_oop": row["mean_oop"],
            "median_oop": row["median_oop"],
            "incremental_cost": row["incremental_cost"],
            "n": int(row["n"]),
            "source": "stratified",
        }

    # Fallback: try relaxing sex
    match = _cost_table[
        (_cost_table["condition"] == condition)
        & (_cost_table["age_group"] == age_group)
        & (_cost_table["insurance_type"] == ins_type)
    ]
    if len(match) > 0:
        return {
            "mean_total_exp": round(match["mean_total_exp"].mean(), 2),
            "median_total_exp": round(match["median_total_exp"].mean(), 2),
            "mean_oop": round(match["mean_oop"].mean(), 2),
            "median_oop": round(match["median_oop"].mean(), 2),
            "incremental_cost": round(match["incremental_cost"].mean(), 2),
            "n": int(match["n"].sum()),
            "source": "age_insurance",
        }

    # Final fallback: unstratified summary
    if condition in _condition_summary:
        s = _condition_summary[condition]
        return {
            "mean_total_exp": s["mean_total_exp"],
            "median_total_exp": s["median_total_exp"],
            "mean_oop": s["mean_oop"],
            "median_oop": s["median_oop"],
            "incremental_cost": s["incremental_cost"],
            "n": s["n"],
            "source": "summary",
        }

    return None


def get_condition_summary(condition: str) -> dict | None:
    """Get the unstratified cost summary for a condition."""
    _ensure_loaded()
    return _condition_summary.get(condition)


def get_comorbidity_cost(condition_a: str, condition_b: str) -> dict | None:
    """
    Get the combined cost data for two co-occurring conditions.
    Order doesn't matter.
    """
    _ensure_loaded()

    # Try both orderings of the pair key
    for key in [f"{condition_a}_{condition_b}", f"{condition_b}_{condition_a}"]:
        if key in _comorbidity_costs:
            return _comorbidity_costs[key]
    return None


def get_all_conditions() -> list[str]:
    """Return list of all conditions we have MEPS data for."""
    _ensure_loaded()
    return list(_condition_summary.keys())


def query_drug_cost(condition: str) -> dict | None:
    """
    Query the H239 drug cost data for a condition.

    Returns dict with keys: mean_drug_cost, mean_drug_oop, median_drug_cost,
    n_persons — or None if no drug cost data exists for this condition.
    """
    _ensure_loaded()
    return _drug_costs_by_condition.get(condition)


def query_intervention_cost(intervention: str) -> dict | None:
    """
    Query the H239 intervention drug cost data for a specific intervention.

    Returns dict with keys: mean_annual_cost, mean_annual_oop,
    median_annual_cost, n_persons — or None if not found.
    """
    _ensure_loaded()
    return _intervention_drug_costs.get(intervention)
